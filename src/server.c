/*
 * This file is the thbdb's main program.
 * 
 * Written by M.Yasaka on 6/17/2018
 */

//config.hが存在するなら読み込む
#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif
#include <glib-object.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/protocol/thrift_binary_protocol_factory.h>
#include <thrift/c_glib/protocol/thrift_protocol_factory.h>
#include <thrift/c_glib/server/thrift_server.h>
#include <thrift/c_glib/server/thrift_simple_server.h>
#include <thrift/c_glib/transport/thrift_buffered_transport_factory.h>
#include <thrift/c_glib/transport/thrift_server_socket.h>
#include <thrift/c_glib/transport/thrift_server_transport.h>

#include "gen_c_glib/thbdb_basic.h"
#include "gen_c_glib/thbdb_thbdb_types.h"
#include "common.h"
#include "handler.h"
#include "bdb_operation.h"
#include "server.h"

#if 0
#endif


/* ---------------------------------------------------------------- */


/* Our server object, declared globally so it is accessible within the
   SIGINT signal handler */
ThriftServer *server = NULL;

/* A flag that indicates whether the server was interrupted with
   SIGINT (i.e. Ctrl-C) so we can tell whether its termination was
   abnormal */
gboolean sigint_received = FALSE;

/* ThBDB db path */
char *db_path = NULL; 

/* Handle SIGINT ("Ctrl-C") signals by gracefully stopping the
   server */
static void
sigint_handler (int signal_number)
{
  THRIFT_UNUSED_VAR (signal_number);

  /* Take note we were called */
  sigint_received = TRUE;

  /* Close internal BDB */
  DEBUG_WRITE_LOG( " Closing internal BDB.  " );
  close_bdb();
  
  /* Shut down the server gracefully */
  if (server != NULL)
    thrift_server_stop (server);
}

/**
 * Processing command line arguments.
 *
 */
int proc_args( int argc, char* const argv[] ){

  int i, opt, ret = 0;
  opterr = 0;   /* Disapper error message on stderr. */

  
  while(( opt = getopt( argc, argv, "p:d:" )) != -1 ){

    /* Processing each arguments. */
    switch( opt ){
      
    case 'p':
      printf ( "-p processed! optarg:=%s  \n", optarg );
      listening_port = atoi( optarg );
      if( listening_port < 1000  || listening_port >= 0x7fff ){
        ret = 1;
      }
      break;

    case 'd':
      printf ( "-d processed! optarg:=%s  \n", optarg );
      db_path = optarg;
      break;
      
    default:
      ret = 1;
      break;
      
    }
  }

  // Processing other arguments. (For debug)
  for( i = optind; i < argc; i++ ){
    //printf( "arg = %s \n", argv[i] );
    ret = 1;
  }

  /* If an error was occered, it would print usage. */
  if( ret == 1 ){
    print_usage( argv[0] );
  }
  
  return ret;
}

/**
 * Explain how to use the ThBDB.
 *
 */
void print_usage( char* const program ){
      printf( "Usage: %s [-p socket listening port ]  [-d db file path]\n", program );
}


/**
 * ThBDB main function.
 *
 */
int main ( int argc, char* const argv[]  ){

  ThbdbBasicimplHandler *handler;
  thbdbBasicProcessor *processor;
    
  ThriftServerTransport *server_transport;
  ThriftTransportFactory *transport_factory;
  ThriftProtocolFactory *protocol_factory;

  struct sigaction sigint_action;

  GError *error = NULL;
  int exit_status = 0;
  int ret;

  /* Processing arguments */
  ret = proc_args( argc, argv );
  if( ret  ){
    return ret;
  }  

  /** 
   * Initialize the BDB 
   */
  ret = init_bdb(db_path);
  if ( ret ){
    return EXIT_FAILURE;
  }
  
#if (!GLIB_CHECK_VERSION (2, 36, 0))
  g_type_init ();
#endif

   
  /* Create an instance of our handler, which provides the service's
     methods' implementation */

  handler = 
     g_object_new (TYPE_THBDB_BASICIMPL_HANDLER, 
                   NULL); 
 
  
  /* Create an instance of the service's processor, automatically
     generated by the Thrift compiler, which parses incoming messages
     and dispatches them to the appropriate method in the handler */
  processor =
    g_object_new (THBDB_TYPE_BASIC_PROCESSOR,
                  "handler", handler,
                  NULL);

  /* Create our server socket, which binds to the specified port and
     listens for client connections */
  server_transport =
    g_object_new (THRIFT_TYPE_SERVER_SOCKET,
                  "port", listening_port,
                  NULL);

  /* Create our transport factory, used by the server to wrap "raw"
     incoming connections from the client (in this case with a
     ThriftBufferedTransport to improve performance) */
  transport_factory =
    g_object_new (THRIFT_TYPE_BUFFERED_TRANSPORT_FACTORY,
                  NULL);

  /* Create our protocol factory, which determines which wire protocol
     the server will use (in this case, Thrift's binary protocol) */
  protocol_factory =
    g_object_new (THRIFT_TYPE_BINARY_PROTOCOL_FACTORY,
                  NULL);

  /* Create the server itself */
  server =
    g_object_new (THRIFT_TYPE_SIMPLE_SERVER,
                  "processor",                processor,
                  "server_transport",         server_transport,
                  "input_transport_factory",  transport_factory,
                  "output_transport_factory", transport_factory,
                  "input_protocol_factory",   protocol_factory,
                  "output_protocol_factory",  protocol_factory,
                  NULL);

  /* Install our SIGINT handler, which handles Ctrl-C being pressed by
     stopping the server gracefully (not strictly necessary, but a
     nice touch) */
  memset (&sigint_action, 0, sizeof (sigint_action));
  sigint_action.sa_handler = sigint_handler;
  sigint_action.sa_flags = SA_RESETHAND;
  sigaction (SIGINT, &sigint_action, NULL);

  /* Start the server, which will run until its stop method is invoked
     (from within the SIGINT handler, in this case) */

  DEBUG_WRITE_LOG("Starting the server...");
  printf( "Listening port: %d \n", listening_port );
  
  thrift_server_serve (server, &error);

  /* If the server stopped for any reason other than having been
     interrupted by the user, report the error */
  if (!sigint_received) {
    g_message ("thrift_server_serve: %s",
               error != NULL ? error->message : "(null)");
    g_clear_error (&error);
  }

  DEBUG_WRITE_LOG("done.");
  
  g_object_unref (server);
  g_object_unref (transport_factory);
  g_object_unref (protocol_factory);
  g_object_unref (server_transport);

  g_object_unref (processor);
  g_object_unref (handler);

  return exit_status;

}

