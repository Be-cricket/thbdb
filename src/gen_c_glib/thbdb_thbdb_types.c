/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "thbdb_thbdb_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_ErrorCode(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case THBDB_ERROR_CODE_INVALID_OPERATION:return "THBDB_ERROR_CODE_INVALID_OPERATION";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _thbdbItemProperties
{
  PROP_THBDB_ITEM_0,
  PROP_THBDB_ITEM_KEY,
  PROP_THBDB_ITEM_VALUE
};

/* reads a item object */
static gint32
thbdb_item_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbItem * this_object = THBDB_ITEM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_item_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbItem * this_object = THBDB_ITEM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Item", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_item_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  thbdbItem *self = THBDB_ITEM (object);

  switch (property_id)
  {
    case PROP_THBDB_ITEM_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_THBDB_ITEM_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_item_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  thbdbItem *self = THBDB_ITEM (object);

  switch (property_id)
  {
    case PROP_THBDB_ITEM_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_THBDB_ITEM_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_item_instance_init (thbdbItem * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
thbdb_item_finalize (GObject *object)
{
  thbdbItem *tobject = THBDB_ITEM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
thbdb_item_class_init (thbdbItemClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_item_read;
  struct_class->write = thbdb_item_write;

  gobject_class->finalize = thbdb_item_finalize;
  gobject_class->get_property = thbdb_item_get_property;
  gobject_class->set_property = thbdb_item_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_ITEM_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_ITEM_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_item_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbItemClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_item_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbItem),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_item_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbItemType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbItemListProperties
{
  PROP_THBDB_ITEM_LIST_0,
  PROP_THBDB_ITEM_LIST_NUM_OF_ITEMS,
  PROP_THBDB_ITEM_LIST_ITEMS
};

/* reads a item_list object */
static gint32
thbdb_item_list_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbItemList * this_object = THBDB_ITEM_LIST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numOfItems, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_numOfItems = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              thbdbItem * _elem0 = NULL;
              if ( _elem0 != NULL)
              {
                g_object_unref (_elem0);
              }
              _elem0 = g_object_new (THBDB_TYPE_ITEM, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
              {
                g_object_unref (_elem0);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->items, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_items = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_item_list_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbItemList * this_object = THBDB_ITEM_LIST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ItemList", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numOfItems", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numOfItems, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "items", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->items->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < this_object->items->len; i1++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->items, i1))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_item_list_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  thbdbItemList *self = THBDB_ITEM_LIST (object);

  switch (property_id)
  {
    case PROP_THBDB_ITEM_LIST_NUM_OF_ITEMS:
      self->numOfItems = g_value_get_int (value);
      self->__isset_numOfItems = TRUE;
      break;

    case PROP_THBDB_ITEM_LIST_ITEMS:
      if (self->items != NULL)
        g_ptr_array_unref (self->items);
      self->items = g_value_dup_boxed (value);
      self->__isset_items = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_item_list_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  thbdbItemList *self = THBDB_ITEM_LIST (object);

  switch (property_id)
  {
    case PROP_THBDB_ITEM_LIST_NUM_OF_ITEMS:
      g_value_set_int (value, self->numOfItems);
      break;

    case PROP_THBDB_ITEM_LIST_ITEMS:
      g_value_set_boxed (value, self->items);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_item_list_instance_init (thbdbItemList * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->numOfItems = 0;
  object->__isset_numOfItems = FALSE;
  object->items = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_items = FALSE;
}

static void 
thbdb_item_list_finalize (GObject *object)
{
  thbdbItemList *tobject = THBDB_ITEM_LIST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->items != NULL)
  {
    g_ptr_array_unref (tobject->items);
    tobject->items = NULL;
  }
}

static void
thbdb_item_list_class_init (thbdbItemListClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_item_list_read;
  struct_class->write = thbdb_item_list_write;

  gobject_class->finalize = thbdb_item_list_finalize;
  gobject_class->get_property = thbdb_item_list_get_property;
  gobject_class->set_property = thbdb_item_list_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_ITEM_LIST_NUM_OF_ITEMS,
     g_param_spec_int ("numOfItems",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_ITEM_LIST_ITEMS,
     g_param_spec_boxed ("items",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thbdb_item_list_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbItemListClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_item_list_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbItemList),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_item_list_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbItemListType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbKeysProperties
{
  PROP_THBDB_KEYS_0,
  PROP_THBDB_KEYS_NUM_OF_KEYS,
  PROP_THBDB_KEYS_KEY
};

/* reads a keys object */
static gint32
thbdb_keys_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbKeys * this_object = THBDB_KEYS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numOfKeys, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_numOfKeys = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem2 = NULL;
              if (_elem2 != NULL)
              {
                g_free(_elem2);
                _elem2 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem2, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->key, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_keys_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbKeys * this_object = THBDB_KEYS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Keys", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numOfKeys", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numOfKeys, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) this_object->key->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < this_object->key->len; i3++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->key, i3)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_keys_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  thbdbKeys *self = THBDB_KEYS (object);

  switch (property_id)
  {
    case PROP_THBDB_KEYS_NUM_OF_KEYS:
      self->numOfKeys = g_value_get_int (value);
      self->__isset_numOfKeys = TRUE;
      break;

    case PROP_THBDB_KEYS_KEY:
      if (self->key != NULL)
        g_ptr_array_unref (self->key);
      self->key = g_value_dup_boxed (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_keys_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  thbdbKeys *self = THBDB_KEYS (object);

  switch (property_id)
  {
    case PROP_THBDB_KEYS_NUM_OF_KEYS:
      g_value_set_int (value, self->numOfKeys);
      break;

    case PROP_THBDB_KEYS_KEY:
      g_value_set_boxed (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_keys_instance_init (thbdbKeys * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->numOfKeys = 0;
  object->__isset_numOfKeys = FALSE;
  object->key = g_ptr_array_new_with_free_func (g_free);
  object->__isset_key = FALSE;
}

static void 
thbdb_keys_finalize (GObject *object)
{
  thbdbKeys *tobject = THBDB_KEYS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_ptr_array_unref (tobject->key);
    tobject->key = NULL;
  }
}

static void
thbdb_keys_class_init (thbdbKeysClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_keys_read;
  struct_class->write = thbdb_keys_write;

  gobject_class->finalize = thbdb_keys_finalize;
  gobject_class->get_property = thbdb_keys_get_property;
  gobject_class->set_property = thbdb_keys_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_KEYS_NUM_OF_KEYS,
     g_param_spec_int ("numOfKeys",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_KEYS_KEY,
     g_param_spec_boxed ("key",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
thbdb_keys_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbKeysClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_keys_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbKeys),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_keys_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbKeysType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbInvalidOperationProperties
{
  PROP_THBDB_INVALID_OPERATION_0,
  PROP_THBDB_INVALID_OPERATION_ERROR_CODE,
  PROP_THBDB_INVALID_OPERATION_MESSAGE
};

/* reads a invalid_operation object */
static gint32
thbdb_invalid_operation_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbInvalidOperation * this_object = THBDB_INVALID_OPERATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->errorCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errorCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_invalid_operation_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbInvalidOperation * this_object = THBDB_INVALID_OPERATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InvalidOperation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errorCode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->errorCode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_invalid_operation_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  thbdbInvalidOperation *self = THBDB_INVALID_OPERATION (object);

  switch (property_id)
  {
    case PROP_THBDB_INVALID_OPERATION_ERROR_CODE:
      self->errorCode = g_value_get_int (value);
      self->__isset_errorCode = TRUE;
      break;

    case PROP_THBDB_INVALID_OPERATION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_invalid_operation_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  thbdbInvalidOperation *self = THBDB_INVALID_OPERATION (object);

  switch (property_id)
  {
    case PROP_THBDB_INVALID_OPERATION_ERROR_CODE:
      g_value_set_int (value, self->errorCode);
      break;

    case PROP_THBDB_INVALID_OPERATION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_invalid_operation_instance_init (thbdbInvalidOperation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errorCode = 0;
  object->__isset_errorCode = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
thbdb_invalid_operation_finalize (GObject *object)
{
  thbdbInvalidOperation *tobject = THBDB_INVALID_OPERATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
thbdb_invalid_operation_class_init (thbdbInvalidOperationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_invalid_operation_read;
  struct_class->write = thbdb_invalid_operation_write;

  gobject_class->finalize = thbdb_invalid_operation_finalize;
  gobject_class->get_property = thbdb_invalid_operation_get_property;
  gobject_class->set_property = thbdb_invalid_operation_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_INVALID_OPERATION_ERROR_CODE,
     g_param_spec_int ("errorCode",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_INVALID_OPERATION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_invalid_operation_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbInvalidOperationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_invalid_operation_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbInvalidOperation),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_invalid_operation_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbInvalidOperationType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define THBDB_INVALID_OPERATION_ERROR_DOMAIN "thbdb_invalid_operation_error_quark"
GQuark
thbdb_invalid_operation_error_quark (void)
{
  return g_quark_from_static_string (THBDB_INVALID_OPERATION_ERROR_DOMAIN);
}

/* constants */

enum _thbdbBasicPutArgsProperties
{
  PROP_THBDB_BASIC_PUT_ARGS_0,
  PROP_THBDB_BASIC_PUT_ARGS_KEY,
  PROP_THBDB_BASIC_PUT_ARGS_VALUE
};

/* reads a basic_put_args object */
static gint32
thbdb_basic_put_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicPutArgs * this_object = THBDB_BASIC_PUT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_put_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicPutArgs * this_object = THBDB_BASIC_PUT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicPutArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_put_args_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  thbdbBasicPutArgs *self = THBDB_BASIC_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_PUT_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_THBDB_BASIC_PUT_ARGS_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_put_args_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  thbdbBasicPutArgs *self = THBDB_BASIC_PUT_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_PUT_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_THBDB_BASIC_PUT_ARGS_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_put_args_instance_init (thbdbBasicPutArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
thbdb_basic_put_args_finalize (GObject *object)
{
  thbdbBasicPutArgs *tobject = THBDB_BASIC_PUT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
thbdb_basic_put_args_class_init (thbdbBasicPutArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_put_args_read;
  struct_class->write = thbdb_basic_put_args_write;

  gobject_class->finalize = thbdb_basic_put_args_finalize;
  gobject_class->get_property = thbdb_basic_put_args_get_property;
  gobject_class->set_property = thbdb_basic_put_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_PUT_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_PUT_ARGS_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_basic_put_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicPutArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_put_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicPutArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_put_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicPutArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicPutResultProperties
{
  PROP_THBDB_BASIC_PUT_RESULT_0,
  PROP_THBDB_BASIC_PUT_RESULT_EXP
};

/* reads a basic_put_result object */
static gint32
thbdb_basic_put_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicPutResult * this_object = THBDB_BASIC_PUT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exp != NULL)
          {
            g_object_unref (this_object->exp);
          }
          this_object->exp = g_object_new (THBDB_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
          {
            g_object_unref (this_object->exp);
            this_object->exp = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_put_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicPutResult * this_object = THBDB_BASIC_PUT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicPutResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_exp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exp", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_put_result_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  thbdbBasicPutResult *self = THBDB_BASIC_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_PUT_RESULT_EXP:
      if (self->exp != NULL)
        g_object_unref (self->exp);
      self->exp = g_value_dup_object (value);
      self->__isset_exp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_put_result_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  thbdbBasicPutResult *self = THBDB_BASIC_PUT_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_PUT_RESULT_EXP:
      g_value_set_object (value, self->exp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_put_result_instance_init (thbdbBasicPutResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->exp = NULL;
  object->__isset_exp = FALSE;
}

static void 
thbdb_basic_put_result_finalize (GObject *object)
{
  thbdbBasicPutResult *tobject = THBDB_BASIC_PUT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->exp != NULL)
  {
    g_object_unref(tobject->exp);
    tobject->exp = NULL;
  }
}

static void
thbdb_basic_put_result_class_init (thbdbBasicPutResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_put_result_read;
  struct_class->write = thbdb_basic_put_result_write;

  gobject_class->finalize = thbdb_basic_put_result_finalize;
  gobject_class->get_property = thbdb_basic_put_result_get_property;
  gobject_class->set_property = thbdb_basic_put_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_PUT_RESULT_EXP,
     g_param_spec_object ("exp",
                         NULL,
                         NULL,
                         THBDB_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
thbdb_basic_put_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicPutResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_put_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicPutResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_put_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicPutResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicPutAsyncArgsProperties
{
  PROP_THBDB_BASIC_PUT_ASYNC_ARGS_0,
  PROP_THBDB_BASIC_PUT_ASYNC_ARGS_KEY,
  PROP_THBDB_BASIC_PUT_ASYNC_ARGS_VALUE
};

/* reads a basic_put_async_args object */
static gint32
thbdb_basic_put_async_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicPutAsyncArgs * this_object = THBDB_BASIC_PUT_ASYNC_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_put_async_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicPutAsyncArgs * this_object = THBDB_BASIC_PUT_ASYNC_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicPutAsyncArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_put_async_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  thbdbBasicPutAsyncArgs *self = THBDB_BASIC_PUT_ASYNC_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_PUT_ASYNC_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_THBDB_BASIC_PUT_ASYNC_ARGS_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_put_async_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  thbdbBasicPutAsyncArgs *self = THBDB_BASIC_PUT_ASYNC_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_PUT_ASYNC_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_THBDB_BASIC_PUT_ASYNC_ARGS_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_put_async_args_instance_init (thbdbBasicPutAsyncArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
thbdb_basic_put_async_args_finalize (GObject *object)
{
  thbdbBasicPutAsyncArgs *tobject = THBDB_BASIC_PUT_ASYNC_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
thbdb_basic_put_async_args_class_init (thbdbBasicPutAsyncArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_put_async_args_read;
  struct_class->write = thbdb_basic_put_async_args_write;

  gobject_class->finalize = thbdb_basic_put_async_args_finalize;
  gobject_class->get_property = thbdb_basic_put_async_args_get_property;
  gobject_class->set_property = thbdb_basic_put_async_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_PUT_ASYNC_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_PUT_ASYNC_ARGS_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_basic_put_async_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicPutAsyncArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_put_async_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicPutAsyncArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_put_async_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicPutAsyncArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicExistsArgsProperties
{
  PROP_THBDB_BASIC_EXISTS_ARGS_0,
  PROP_THBDB_BASIC_EXISTS_ARGS_KEY
};

/* reads a basic_exists_args object */
static gint32
thbdb_basic_exists_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicExistsArgs * this_object = THBDB_BASIC_EXISTS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_exists_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicExistsArgs * this_object = THBDB_BASIC_EXISTS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicExistsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_exists_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  thbdbBasicExistsArgs *self = THBDB_BASIC_EXISTS_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_EXISTS_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_exists_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  thbdbBasicExistsArgs *self = THBDB_BASIC_EXISTS_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_EXISTS_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_exists_args_instance_init (thbdbBasicExistsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
thbdb_basic_exists_args_finalize (GObject *object)
{
  thbdbBasicExistsArgs *tobject = THBDB_BASIC_EXISTS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
thbdb_basic_exists_args_class_init (thbdbBasicExistsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_exists_args_read;
  struct_class->write = thbdb_basic_exists_args_write;

  gobject_class->finalize = thbdb_basic_exists_args_finalize;
  gobject_class->get_property = thbdb_basic_exists_args_get_property;
  gobject_class->set_property = thbdb_basic_exists_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_EXISTS_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_basic_exists_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicExistsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_exists_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicExistsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_exists_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicExistsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicExistsResultProperties
{
  PROP_THBDB_BASIC_EXISTS_RESULT_0,
  PROP_THBDB_BASIC_EXISTS_RESULT_SUCCESS,
  PROP_THBDB_BASIC_EXISTS_RESULT_EXP
};

/* reads a basic_exists_result object */
static gint32
thbdb_basic_exists_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicExistsResult * this_object = THBDB_BASIC_EXISTS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exp != NULL)
          {
            g_object_unref (this_object->exp);
          }
          this_object->exp = g_object_new (THBDB_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
          {
            g_object_unref (this_object->exp);
            this_object->exp = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_exists_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicExistsResult * this_object = THBDB_BASIC_EXISTS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicExistsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_exp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exp", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_exists_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  thbdbBasicExistsResult *self = THBDB_BASIC_EXISTS_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_EXISTS_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THBDB_BASIC_EXISTS_RESULT_EXP:
      if (self->exp != NULL)
        g_object_unref (self->exp);
      self->exp = g_value_dup_object (value);
      self->__isset_exp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_exists_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  thbdbBasicExistsResult *self = THBDB_BASIC_EXISTS_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_EXISTS_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_THBDB_BASIC_EXISTS_RESULT_EXP:
      g_value_set_object (value, self->exp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_exists_result_instance_init (thbdbBasicExistsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->exp = NULL;
  object->__isset_exp = FALSE;
}

static void 
thbdb_basic_exists_result_finalize (GObject *object)
{
  thbdbBasicExistsResult *tobject = THBDB_BASIC_EXISTS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->exp != NULL)
  {
    g_object_unref(tobject->exp);
    tobject->exp = NULL;
  }
}

static void
thbdb_basic_exists_result_class_init (thbdbBasicExistsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_exists_result_read;
  struct_class->write = thbdb_basic_exists_result_write;

  gobject_class->finalize = thbdb_basic_exists_result_finalize;
  gobject_class->get_property = thbdb_basic_exists_result_get_property;
  gobject_class->set_property = thbdb_basic_exists_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_EXISTS_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_EXISTS_RESULT_EXP,
     g_param_spec_object ("exp",
                         NULL,
                         NULL,
                         THBDB_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
thbdb_basic_exists_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicExistsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_exists_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicExistsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_exists_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicExistsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicGetArgsProperties
{
  PROP_THBDB_BASIC_GET_ARGS_0,
  PROP_THBDB_BASIC_GET_ARGS_KEY
};

/* reads a basic_get_args object */
static gint32
thbdb_basic_get_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetArgs * this_object = THBDB_BASIC_GET_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetArgs * this_object = THBDB_BASIC_GET_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_get_args_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  thbdbBasicGetArgs *self = THBDB_BASIC_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_get_args_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  thbdbBasicGetArgs *self = THBDB_BASIC_GET_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_get_args_instance_init (thbdbBasicGetArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
thbdb_basic_get_args_finalize (GObject *object)
{
  thbdbBasicGetArgs *tobject = THBDB_BASIC_GET_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
thbdb_basic_get_args_class_init (thbdbBasicGetArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_args_read;
  struct_class->write = thbdb_basic_get_args_write;

  gobject_class->finalize = thbdb_basic_get_args_finalize;
  gobject_class->get_property = thbdb_basic_get_args_get_property;
  gobject_class->set_property = thbdb_basic_get_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_basic_get_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicGetResultProperties
{
  PROP_THBDB_BASIC_GET_RESULT_0,
  PROP_THBDB_BASIC_GET_RESULT_SUCCESS,
  PROP_THBDB_BASIC_GET_RESULT_EXP
};

/* reads a basic_get_result object */
static gint32
thbdb_basic_get_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetResult * this_object = THBDB_BASIC_GET_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exp != NULL)
          {
            g_object_unref (this_object->exp);
          }
          this_object->exp = g_object_new (THBDB_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
          {
            g_object_unref (this_object->exp);
            this_object->exp = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetResult * this_object = THBDB_BASIC_GET_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_exp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exp", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_get_result_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  thbdbBasicGetResult *self = THBDB_BASIC_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THBDB_BASIC_GET_RESULT_EXP:
      if (self->exp != NULL)
        g_object_unref (self->exp);
      self->exp = g_value_dup_object (value);
      self->__isset_exp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_get_result_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  thbdbBasicGetResult *self = THBDB_BASIC_GET_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_THBDB_BASIC_GET_RESULT_EXP:
      g_value_set_object (value, self->exp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_get_result_instance_init (thbdbBasicGetResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->exp = NULL;
  object->__isset_exp = FALSE;
}

static void 
thbdb_basic_get_result_finalize (GObject *object)
{
  thbdbBasicGetResult *tobject = THBDB_BASIC_GET_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->exp != NULL)
  {
    g_object_unref(tobject->exp);
    tobject->exp = NULL;
  }
}

static void
thbdb_basic_get_result_class_init (thbdbBasicGetResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_result_read;
  struct_class->write = thbdb_basic_get_result_write;

  gobject_class->finalize = thbdb_basic_get_result_finalize;
  gobject_class->get_property = thbdb_basic_get_result_get_property;
  gobject_class->set_property = thbdb_basic_get_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_RESULT_EXP,
     g_param_spec_object ("exp",
                         NULL,
                         NULL,
                         THBDB_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
thbdb_basic_get_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicRemoveArgsProperties
{
  PROP_THBDB_BASIC_REMOVE_ARGS_0,
  PROP_THBDB_BASIC_REMOVE_ARGS_KEY
};

/* reads a basic_remove_args object */
static gint32
thbdb_basic_remove_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicRemoveArgs * this_object = THBDB_BASIC_REMOVE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_remove_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicRemoveArgs * this_object = THBDB_BASIC_REMOVE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicRemoveArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_remove_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  thbdbBasicRemoveArgs *self = THBDB_BASIC_REMOVE_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_REMOVE_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_remove_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  thbdbBasicRemoveArgs *self = THBDB_BASIC_REMOVE_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_REMOVE_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_remove_args_instance_init (thbdbBasicRemoveArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
}

static void 
thbdb_basic_remove_args_finalize (GObject *object)
{
  thbdbBasicRemoveArgs *tobject = THBDB_BASIC_REMOVE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
}

static void
thbdb_basic_remove_args_class_init (thbdbBasicRemoveArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_remove_args_read;
  struct_class->write = thbdb_basic_remove_args_write;

  gobject_class->finalize = thbdb_basic_remove_args_finalize;
  gobject_class->get_property = thbdb_basic_remove_args_get_property;
  gobject_class->set_property = thbdb_basic_remove_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_REMOVE_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_basic_remove_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicRemoveArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_remove_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicRemoveArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_remove_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicRemoveArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicRemoveResultProperties
{
  PROP_THBDB_BASIC_REMOVE_RESULT_0,
  PROP_THBDB_BASIC_REMOVE_RESULT_EXP
};

/* reads a basic_remove_result object */
static gint32
thbdb_basic_remove_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicRemoveResult * this_object = THBDB_BASIC_REMOVE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exp != NULL)
          {
            g_object_unref (this_object->exp);
          }
          this_object->exp = g_object_new (THBDB_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
          {
            g_object_unref (this_object->exp);
            this_object->exp = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_remove_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicRemoveResult * this_object = THBDB_BASIC_REMOVE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicRemoveResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_exp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exp", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_remove_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  thbdbBasicRemoveResult *self = THBDB_BASIC_REMOVE_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_REMOVE_RESULT_EXP:
      if (self->exp != NULL)
        g_object_unref (self->exp);
      self->exp = g_value_dup_object (value);
      self->__isset_exp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_remove_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  thbdbBasicRemoveResult *self = THBDB_BASIC_REMOVE_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_REMOVE_RESULT_EXP:
      g_value_set_object (value, self->exp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_remove_result_instance_init (thbdbBasicRemoveResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->exp = NULL;
  object->__isset_exp = FALSE;
}

static void 
thbdb_basic_remove_result_finalize (GObject *object)
{
  thbdbBasicRemoveResult *tobject = THBDB_BASIC_REMOVE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->exp != NULL)
  {
    g_object_unref(tobject->exp);
    tobject->exp = NULL;
  }
}

static void
thbdb_basic_remove_result_class_init (thbdbBasicRemoveResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_remove_result_read;
  struct_class->write = thbdb_basic_remove_result_write;

  gobject_class->finalize = thbdb_basic_remove_result_finalize;
  gobject_class->get_property = thbdb_basic_remove_result_get_property;
  gobject_class->set_property = thbdb_basic_remove_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_REMOVE_RESULT_EXP,
     g_param_spec_object ("exp",
                         NULL,
                         NULL,
                         THBDB_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
thbdb_basic_remove_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicRemoveResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_remove_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicRemoveResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_remove_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicRemoveResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a basic_get_keys_args object */
static gint32
thbdb_basic_get_keys_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetKeysArgs * this_object = THBDB_BASIC_GET_KEYS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_keys_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetKeysArgs * this_object = THBDB_BASIC_GET_KEYS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetKeysArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
thbdb_basic_get_keys_args_instance_init (thbdbBasicGetKeysArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
thbdb_basic_get_keys_args_finalize (GObject *object)
{
  thbdbBasicGetKeysArgs *tobject = THBDB_BASIC_GET_KEYS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thbdb_basic_get_keys_args_class_init (thbdbBasicGetKeysArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_keys_args_read;
  struct_class->write = thbdb_basic_get_keys_args_write;

  gobject_class->finalize = thbdb_basic_get_keys_args_finalize;
}

GType
thbdb_basic_get_keys_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetKeysArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_keys_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetKeysArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_keys_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetKeysArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicGetKeysResultProperties
{
  PROP_THBDB_BASIC_GET_KEYS_RESULT_0,
  PROP_THBDB_BASIC_GET_KEYS_RESULT_SUCCESS,
  PROP_THBDB_BASIC_GET_KEYS_RESULT_EXP
};

/* reads a basic_get_keys_result object */
static gint32
thbdb_basic_get_keys_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetKeysResult * this_object = THBDB_BASIC_GET_KEYS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exp != NULL)
          {
            g_object_unref (this_object->exp);
          }
          this_object->exp = g_object_new (THBDB_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
          {
            g_object_unref (this_object->exp);
            this_object->exp = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_keys_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetKeysResult * this_object = THBDB_BASIC_GET_KEYS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetKeysResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_exp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exp", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_get_keys_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  thbdbBasicGetKeysResult *self = THBDB_BASIC_GET_KEYS_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_KEYS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THBDB_BASIC_GET_KEYS_RESULT_EXP:
      if (self->exp != NULL)
        g_object_unref (self->exp);
      self->exp = g_value_dup_object (value);
      self->__isset_exp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_get_keys_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  thbdbBasicGetKeysResult *self = THBDB_BASIC_GET_KEYS_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_KEYS_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_THBDB_BASIC_GET_KEYS_RESULT_EXP:
      g_value_set_object (value, self->exp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_get_keys_result_instance_init (thbdbBasicGetKeysResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (THBDB_TYPE_KEYS, NULL);
  object->__isset_success = FALSE;
  object->exp = NULL;
  object->__isset_exp = FALSE;
}

static void 
thbdb_basic_get_keys_result_finalize (GObject *object)
{
  thbdbBasicGetKeysResult *tobject = THBDB_BASIC_GET_KEYS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->exp != NULL)
  {
    g_object_unref(tobject->exp);
    tobject->exp = NULL;
  }
}

static void
thbdb_basic_get_keys_result_class_init (thbdbBasicGetKeysResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_keys_result_read;
  struct_class->write = thbdb_basic_get_keys_result_write;

  gobject_class->finalize = thbdb_basic_get_keys_result_finalize;
  gobject_class->get_property = thbdb_basic_get_keys_result_get_property;
  gobject_class->set_property = thbdb_basic_get_keys_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_KEYS_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         THBDB_TYPE_KEYS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_KEYS_RESULT_EXP,
     g_param_spec_object ("exp",
                         NULL,
                         NULL,
                         THBDB_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
thbdb_basic_get_keys_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetKeysResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_keys_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetKeysResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_keys_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetKeysResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicGetKeysByPositionArgsProperties
{
  PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_0,
  PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_POSITION,
  PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_SIZE
};

/* reads a basic_get_keys_by_position_args object */
static gint32
thbdb_basic_get_keys_by_position_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetKeysByPositionArgs * this_object = THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->position, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_position = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_keys_by_position_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetKeysByPositionArgs * this_object = THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetKeysByPositionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "position", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->position, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "size", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->size, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_get_keys_by_position_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  thbdbBasicGetKeysByPositionArgs *self = THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_POSITION:
      self->position = g_value_get_int (value);
      self->__isset_position = TRUE;
      break;

    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_SIZE:
      self->size = g_value_get_int (value);
      self->__isset_size = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_get_keys_by_position_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  thbdbBasicGetKeysByPositionArgs *self = THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_POSITION:
      g_value_set_int (value, self->position);
      break;

    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_SIZE:
      g_value_set_int (value, self->size);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_get_keys_by_position_args_instance_init (thbdbBasicGetKeysByPositionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->position = 0;
  object->__isset_position = FALSE;
  object->size = 0;
  object->__isset_size = FALSE;
}

static void 
thbdb_basic_get_keys_by_position_args_finalize (GObject *object)
{
  thbdbBasicGetKeysByPositionArgs *tobject = THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thbdb_basic_get_keys_by_position_args_class_init (thbdbBasicGetKeysByPositionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_keys_by_position_args_read;
  struct_class->write = thbdb_basic_get_keys_by_position_args_write;

  gobject_class->finalize = thbdb_basic_get_keys_by_position_args_finalize;
  gobject_class->get_property = thbdb_basic_get_keys_by_position_args_get_property;
  gobject_class->set_property = thbdb_basic_get_keys_by_position_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_POSITION,
     g_param_spec_int ("position",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_ARGS_SIZE,
     g_param_spec_int ("size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
thbdb_basic_get_keys_by_position_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetKeysByPositionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_keys_by_position_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetKeysByPositionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_keys_by_position_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetKeysByPositionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicGetKeysByPositionResultProperties
{
  PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_0,
  PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_SUCCESS,
  PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_EXP
};

/* reads a basic_get_keys_by_position_result object */
static gint32
thbdb_basic_get_keys_by_position_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetKeysByPositionResult * this_object = THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exp != NULL)
          {
            g_object_unref (this_object->exp);
          }
          this_object->exp = g_object_new (THBDB_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
          {
            g_object_unref (this_object->exp);
            this_object->exp = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_keys_by_position_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetKeysByPositionResult * this_object = THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetKeysByPositionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_exp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exp", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_get_keys_by_position_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  thbdbBasicGetKeysByPositionResult *self = THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_EXP:
      if (self->exp != NULL)
        g_object_unref (self->exp);
      self->exp = g_value_dup_object (value);
      self->__isset_exp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_get_keys_by_position_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  thbdbBasicGetKeysByPositionResult *self = THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_EXP:
      g_value_set_object (value, self->exp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_get_keys_by_position_result_instance_init (thbdbBasicGetKeysByPositionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (THBDB_TYPE_KEYS, NULL);
  object->__isset_success = FALSE;
  object->exp = NULL;
  object->__isset_exp = FALSE;
}

static void 
thbdb_basic_get_keys_by_position_result_finalize (GObject *object)
{
  thbdbBasicGetKeysByPositionResult *tobject = THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->exp != NULL)
  {
    g_object_unref(tobject->exp);
    tobject->exp = NULL;
  }
}

static void
thbdb_basic_get_keys_by_position_result_class_init (thbdbBasicGetKeysByPositionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_keys_by_position_result_read;
  struct_class->write = thbdb_basic_get_keys_by_position_result_write;

  gobject_class->finalize = thbdb_basic_get_keys_by_position_result_finalize;
  gobject_class->get_property = thbdb_basic_get_keys_by_position_result_get_property;
  gobject_class->set_property = thbdb_basic_get_keys_by_position_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         THBDB_TYPE_KEYS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_KEYS_BY_POSITION_RESULT_EXP,
     g_param_spec_object ("exp",
                         NULL,
                         NULL,
                         THBDB_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
thbdb_basic_get_keys_by_position_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetKeysByPositionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_keys_by_position_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetKeysByPositionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_keys_by_position_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetKeysByPositionResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a basic_ping_args object */
static gint32
thbdb_basic_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicPingArgs * this_object = THBDB_BASIC_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicPingArgs * this_object = THBDB_BASIC_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicPingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
thbdb_basic_ping_args_instance_init (thbdbBasicPingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
thbdb_basic_ping_args_finalize (GObject *object)
{
  thbdbBasicPingArgs *tobject = THBDB_BASIC_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thbdb_basic_ping_args_class_init (thbdbBasicPingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_ping_args_read;
  struct_class->write = thbdb_basic_ping_args_write;

  gobject_class->finalize = thbdb_basic_ping_args_finalize;
}

GType
thbdb_basic_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicPingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicPingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicPingArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a basic_ping_result object */
static gint32
thbdb_basic_ping_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicPingResult * this_object = THBDB_BASIC_PING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_ping_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicPingResult * this_object = THBDB_BASIC_PING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicPingResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
thbdb_basic_ping_result_instance_init (thbdbBasicPingResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
thbdb_basic_ping_result_finalize (GObject *object)
{
  thbdbBasicPingResult *tobject = THBDB_BASIC_PING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thbdb_basic_ping_result_class_init (thbdbBasicPingResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_ping_result_read;
  struct_class->write = thbdb_basic_ping_result_write;

  gobject_class->finalize = thbdb_basic_ping_result_finalize;
}

GType
thbdb_basic_ping_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicPingResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_ping_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicPingResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_ping_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicPingResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicHelloArgsProperties
{
  PROP_THBDB_BASIC_HELLO_ARGS_0,
  PROP_THBDB_BASIC_HELLO_ARGS_ARG
};

/* reads a basic_hello_args object */
static gint32
thbdb_basic_hello_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicHelloArgs * this_object = THBDB_BASIC_HELLO_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->arg != NULL)
          {
            g_free(this_object->arg);
            this_object->arg = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->arg, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_arg = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_hello_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicHelloArgs * this_object = THBDB_BASIC_HELLO_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicHelloArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "arg", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->arg, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_hello_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  thbdbBasicHelloArgs *self = THBDB_BASIC_HELLO_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_HELLO_ARGS_ARG:
      if (self->arg != NULL)
        g_free (self->arg);
      self->arg = g_value_dup_string (value);
      self->__isset_arg = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_hello_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  thbdbBasicHelloArgs *self = THBDB_BASIC_HELLO_ARGS (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_HELLO_ARGS_ARG:
      g_value_set_string (value, self->arg);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_hello_args_instance_init (thbdbBasicHelloArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->arg = NULL;
  object->__isset_arg = FALSE;
}

static void 
thbdb_basic_hello_args_finalize (GObject *object)
{
  thbdbBasicHelloArgs *tobject = THBDB_BASIC_HELLO_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->arg != NULL)
  {
    g_free(tobject->arg);
    tobject->arg = NULL;
  }
}

static void
thbdb_basic_hello_args_class_init (thbdbBasicHelloArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_hello_args_read;
  struct_class->write = thbdb_basic_hello_args_write;

  gobject_class->finalize = thbdb_basic_hello_args_finalize;
  gobject_class->get_property = thbdb_basic_hello_args_get_property;
  gobject_class->set_property = thbdb_basic_hello_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_HELLO_ARGS_ARG,
     g_param_spec_string ("arg",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_basic_hello_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicHelloArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_hello_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicHelloArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_hello_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicHelloArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicHelloResultProperties
{
  PROP_THBDB_BASIC_HELLO_RESULT_0,
  PROP_THBDB_BASIC_HELLO_RESULT_SUCCESS
};

/* reads a basic_hello_result object */
static gint32
thbdb_basic_hello_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicHelloResult * this_object = THBDB_BASIC_HELLO_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_hello_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicHelloResult * this_object = THBDB_BASIC_HELLO_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicHelloResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_hello_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  thbdbBasicHelloResult *self = THBDB_BASIC_HELLO_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_HELLO_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_hello_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  thbdbBasicHelloResult *self = THBDB_BASIC_HELLO_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_HELLO_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_hello_result_instance_init (thbdbBasicHelloResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
}

static void 
thbdb_basic_hello_result_finalize (GObject *object)
{
  thbdbBasicHelloResult *tobject = THBDB_BASIC_HELLO_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
}

static void
thbdb_basic_hello_result_class_init (thbdbBasicHelloResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_hello_result_read;
  struct_class->write = thbdb_basic_hello_result_write;

  gobject_class->finalize = thbdb_basic_hello_result_finalize;
  gobject_class->get_property = thbdb_basic_hello_result_get_property;
  gobject_class->set_property = thbdb_basic_hello_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_HELLO_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
thbdb_basic_hello_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicHelloResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_hello_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicHelloResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_hello_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicHelloResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a basic_get_status_args object */
static gint32
thbdb_basic_get_status_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetStatusArgs * this_object = THBDB_BASIC_GET_STATUS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_status_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetStatusArgs * this_object = THBDB_BASIC_GET_STATUS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetStatusArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
thbdb_basic_get_status_args_instance_init (thbdbBasicGetStatusArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
thbdb_basic_get_status_args_finalize (GObject *object)
{
  thbdbBasicGetStatusArgs *tobject = THBDB_BASIC_GET_STATUS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thbdb_basic_get_status_args_class_init (thbdbBasicGetStatusArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_status_args_read;
  struct_class->write = thbdb_basic_get_status_args_write;

  gobject_class->finalize = thbdb_basic_get_status_args_finalize;
}

GType
thbdb_basic_get_status_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetStatusArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_status_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetStatusArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_status_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetStatusArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicGetStatusResultProperties
{
  PROP_THBDB_BASIC_GET_STATUS_RESULT_0,
  PROP_THBDB_BASIC_GET_STATUS_RESULT_SUCCESS
};

/* reads a basic_get_status_result object */
static gint32
thbdb_basic_get_status_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicGetStatusResult * this_object = THBDB_BASIC_GET_STATUS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_get_status_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicGetStatusResult * this_object = THBDB_BASIC_GET_STATUS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicGetStatusResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_get_status_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  thbdbBasicGetStatusResult *self = THBDB_BASIC_GET_STATUS_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_STATUS_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_get_status_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  thbdbBasicGetStatusResult *self = THBDB_BASIC_GET_STATUS_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_GET_STATUS_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_get_status_result_instance_init (thbdbBasicGetStatusResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
thbdb_basic_get_status_result_finalize (GObject *object)
{
  thbdbBasicGetStatusResult *tobject = THBDB_BASIC_GET_STATUS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thbdb_basic_get_status_result_class_init (thbdbBasicGetStatusResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_get_status_result_read;
  struct_class->write = thbdb_basic_get_status_result_write;

  gobject_class->finalize = thbdb_basic_get_status_result_finalize;
  gobject_class->get_property = thbdb_basic_get_status_result_get_property;
  gobject_class->set_property = thbdb_basic_get_status_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_GET_STATUS_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
thbdb_basic_get_status_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicGetStatusResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_get_status_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicGetStatusResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_get_status_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicGetStatusResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a basic_compact_args object */
static gint32
thbdb_basic_compact_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicCompactArgs * this_object = THBDB_BASIC_COMPACT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_compact_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicCompactArgs * this_object = THBDB_BASIC_COMPACT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicCompactArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
thbdb_basic_compact_args_instance_init (thbdbBasicCompactArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
thbdb_basic_compact_args_finalize (GObject *object)
{
  thbdbBasicCompactArgs *tobject = THBDB_BASIC_COMPACT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
thbdb_basic_compact_args_class_init (thbdbBasicCompactArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_compact_args_read;
  struct_class->write = thbdb_basic_compact_args_write;

  gobject_class->finalize = thbdb_basic_compact_args_finalize;
}

GType
thbdb_basic_compact_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicCompactArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_compact_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicCompactArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_compact_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicCompactArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _thbdbBasicCompactResultProperties
{
  PROP_THBDB_BASIC_COMPACT_RESULT_0,
  PROP_THBDB_BASIC_COMPACT_RESULT_SUCCESS,
  PROP_THBDB_BASIC_COMPACT_RESULT_EXP
};

/* reads a basic_compact_result object */
static gint32
thbdb_basic_compact_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  thbdbBasicCompactResult * this_object = THBDB_BASIC_COMPACT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->exp != NULL)
          {
            g_object_unref (this_object->exp);
          }
          this_object->exp = g_object_new (THBDB_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
          {
            g_object_unref (this_object->exp);
            this_object->exp = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_exp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
thbdb_basic_compact_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  thbdbBasicCompactResult * this_object = THBDB_BASIC_COMPACT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BasicCompactResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_exp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "exp", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->exp), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
thbdb_basic_compact_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  thbdbBasicCompactResult *self = THBDB_BASIC_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_COMPACT_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_THBDB_BASIC_COMPACT_RESULT_EXP:
      if (self->exp != NULL)
        g_object_unref (self->exp);
      self->exp = g_value_dup_object (value);
      self->__isset_exp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
thbdb_basic_compact_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  thbdbBasicCompactResult *self = THBDB_BASIC_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_THBDB_BASIC_COMPACT_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_THBDB_BASIC_COMPACT_RESULT_EXP:
      g_value_set_object (value, self->exp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
thbdb_basic_compact_result_instance_init (thbdbBasicCompactResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->exp = NULL;
  object->__isset_exp = FALSE;
}

static void 
thbdb_basic_compact_result_finalize (GObject *object)
{
  thbdbBasicCompactResult *tobject = THBDB_BASIC_COMPACT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->exp != NULL)
  {
    g_object_unref(tobject->exp);
    tobject->exp = NULL;
  }
}

static void
thbdb_basic_compact_result_class_init (thbdbBasicCompactResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = thbdb_basic_compact_result_read;
  struct_class->write = thbdb_basic_compact_result_write;

  gobject_class->finalize = thbdb_basic_compact_result_finalize;
  gobject_class->get_property = thbdb_basic_compact_result_get_property;
  gobject_class->set_property = thbdb_basic_compact_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_COMPACT_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_THBDB_BASIC_COMPACT_RESULT_EXP,
     g_param_spec_object ("exp",
                         NULL,
                         NULL,
                         THBDB_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
thbdb_basic_compact_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (thbdbBasicCompactResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) thbdb_basic_compact_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (thbdbBasicCompactResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) thbdb_basic_compact_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "thbdbBasicCompactResultType",
                                   &type_info, 0);
  }

  return type;
}

